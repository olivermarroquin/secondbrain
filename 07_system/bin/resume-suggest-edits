#!/Users/olivermarroquin/secondbrain/07_system/venvs/docgen/bin/python
import argparse, json, os, re
from pathlib import Path
from datetime import datetime, timezone

def die(msg: str, code=1):
    print(f"ERROR: {msg}")
    raise SystemExit(code)

def load_json(p: Path):
    try:
        return json.loads(p.read_text())
    except Exception as e:
        die(f"invalid JSON: {p} ({e})")

def norm(s: str) -> str:
    s = (s or "").lower()
    s = s.replace("\u2019", "'")
    s = re.sub(r"\s+", " ", s)
    return s.strip()

def has(text: str, kw: str) -> bool:
    kw = (kw or "").strip().lower()
    return bool(kw) and kw in text

def score(sig: dict, text: str):
    pref = [k for k in sig.get("preferred_keywords", []) if isinstance(k, str)]
    neut = [k for k in sig.get("neutral_keywords", []) if isinstance(k, str)]
    anti = [k for k in sig.get("anti_signals", []) if isinstance(k, str)]

    hits_pref = [k for k in pref if has(text, k)]
    hits_neut = [k for k in neut if has(text, k)]
    hits_anti = [k for k in anti if has(text, k)]

    sc = 0
    sc += 10 * len(hits_pref)
    sc += 2 * len(hits_neut)
    sc -= 12 * len(hits_anti)

    ps = sig.get("primary_stack", {}) or {}
    lang = (ps.get("language") or "").lower()
    tool = (ps.get("automation_tool") or "").lower()
    if lang and has(text, lang): sc += 6
    if tool and has(text, tool): sc += 8

    # role bias: Cypress → TS/JS modern web automation
    if has(text, "cypress") and str(sig.get("template_id","")) == "04":
        sc += 10

    return sc, hits_pref, hits_neut, hits_anti

def select_template(family_root: Path, jd_text_norm: str, requested: str):
    rows = []
    for sig_p in family_root.rglob("signals.json"):
        sig = load_json(sig_p)
        sc, hp, hn, ha = score(sig, jd_text_norm)
        rows.append({"score": sc, "sig": sig, "path": sig_p.parent})
    if not rows:
        die(f"no signals.json found under: {family_root}")

    if requested != "auto":
        req = requested.strip().lower()
        for r in rows:
            tid = str(r["sig"].get("template_id","")).zfill(2)
            slug = (r["sig"].get("template_slug") or r["path"].name).lower()
            if req == tid or req == slug or req == slug.replace(tid + "_","") or req == r["path"].name.lower():
                return r, sorted(rows, key=lambda x: x["score"], reverse=True)
        die(f"requested template not found: {requested}")

    rows.sort(key=lambda r: r["score"], reverse=True)
    return rows[0], rows

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--app", required=True)
    ap.add_argument("--template", default="auto", help="auto|template_id|template_slug")
    ap.add_argument("--diff", action="store_true", help="Show BEFORE/AFTER diffs (recommended)")
    ap.add_argument("--family", default="qa_automation_engineer")
    ap.add_argument("--no-write", action="store_true", help="Do not write edit-proposals.json")
    args = ap.parse_args()

    app = Path(args.app).expanduser()
    if not app.is_dir():
        die(f"app dir missing: {app}")

    jm_p = app / "tracking" / "job-meta.json"
    jd_p = app / "jd" / "jd-raw.txt"
    if not jm_p.exists(): die(f"missing: {jm_p}")
    if not jd_p.exists(): die(f"missing: {jd_p}")
    if jd_p.stat().st_size == 0: die(f"jd-raw.txt empty: {jd_p}")

    jm = load_json(jm_p)
    jd_raw = jd_p.read_text(errors="ignore")
    jd_norm = norm(jd_raw)

    family_root = Path.home() / "secondbrain/03_assets/templates/resumes" / args.family
    if not family_root.is_dir():
        die(f"template family root missing: {family_root}")

    best, _rows = select_template(family_root, jd_norm, args.template)
    sig = best["sig"]
    template_path = best["path"]
    template_folder_name = template_path.name
    docx_path = template_path / "resume-master.docx"

    scripts_dir = Path.home() / "secondbrain/01_projects/resume-factory/scripts"
    if not scripts_dir.is_dir():
        die(f"missing scripts dir: {scripts_dir}")
    import sys
    sys.path.insert(0, str(scripts_dir))

    from rf_docx_extract import read_docx_lines, locate_sections, format_numbered_blocks_for_prompt
    from rf_rewrite_client import generate_rewrite_packet_openai
    from rf_render_rewrite_packet import render_rewrite_packet_md
    from rf_proposal_schema import validate_proposals
    from rf_print_diff import print_diff

    # Extract resume text blocks deterministically (source is template)
    lines = read_docx_lines(docx_path)
    header, summary, skills, exp = locate_sections(lines)
    resume_blocks_numbered, line_index = format_numbered_blocks_for_prompt(header, summary, skills, exp, max_exp_lines=90)

    if not os.environ.get("OPENAI_API_KEY"):
        die("missing OPENAI_API_KEY (export it in your shell)")

    payload = generate_rewrite_packet_openai(
        jd_raw=jd_raw,
        resume_blocks_numbered=resume_blocks_numbered,
        signals=sig,
        selected_template=template_folder_name,
        model=os.environ.get("RF_OPENAI_MODEL", None),
        max_proposals=int(os.environ.get("RF_MAX_PROPOSALS", "16")),
        timeout_s=int(os.environ.get("RF_OPENAI_TIMEOUT_S", "90")),
    )

    if payload.get("selected_template") != template_folder_name:
        die(f"LLM selected_template mismatch. expected={template_folder_name} got={payload.get('selected_template')!r}")

    rewrite_packet = payload.get("rewrite_packet") or {}
    # IMPORTANT (Option A): ignore LLM-provided proposals.
    # We compile deterministic proposals from rewrite_packet using before_ref anchors.
    proposals = []

    def _as_lines(v):
        if isinstance(v, list):
            return [str(x).rstrip() for x in v if isinstance(x, str) and x.strip()]
        if isinstance(v, str):
            return [ln.rstrip() for ln in v.splitlines() if ln.strip()]
        return []

    def _sorted_refs(prefix: str):
        refs = [r for r, meta in line_index.items() if r.startswith(prefix) and meta.get("section") in ("SUMMARY","SKILLS","EXPERIENCE")]
        def key(r):
            try:
                return int(r[1:])
            except Exception:
                return 10**9
        return sorted(refs, key=key)

    def _preserve_bullet(before_line: str, after_line: str) -> str:
        b = (before_line or "").lstrip()
        a = (after_line or "").lstrip()
        before_has = b.startswith("•")
        after_has = a.startswith("•")
        if before_has and not after_has:
            return "• " + a
        if (not before_has) and after_has:
            # if template line wasn't a bullet, don't introduce a bullet
            return a.lstrip("•").lstrip()
        return after_line

    def _is_heading_line(ref: str) -> bool:
        # Never replace structural heading lines like "PROFESSIONAL SUMMARY:" / "TECHNICAL SKILL:"
        line = (line_index.get(ref, {}) or {}).get("text", "")
        t = (line or "").strip()
        if not t:
            return True
        # Heuristic: heading lines are often uppercase-ish and end with ":" (and are not bullets)
        if t.endswith(":") and not t.lstrip().startswith("•"):
            return True
        # Also block known headings without relying on exact text
        tu = t.upper().rstrip(":").strip()
        if tu in {"PROFESSIONAL SUMMARY", "SUMMARY", "TECHNICAL SKILL", "TECHNICAL SKILLS", "SKILLS", "PROFESSIONAL EXPERIENCE", "EXPERIENCE"}:
            return True
        return False

    # Compile SUMMARY replacements (replace existing summary lines in order)
    ps_lines = _as_lines(rewrite_packet.get("professional_summary"))
    s_refs = [r for r in _sorted_refs("S") if line_index.get(r, {}).get("section") == "SUMMARY" and not _is_heading_line(r)]
    for i in range(min(len(ps_lines), len(s_refs))):
        ref = s_refs[i]
        before = line_index[ref]["text"]
        after0 = _preserve_bullet(before, ps_lines[i])
        proposals.append({
            "section": "SUMMARY",
            "op": "REPLACE_LINE",
            "before_ref": ref,
            "before": [before],
            "after": [after0],
            "rationale": f"Rewrite packet summary update for {ref}.",
        })

    # Compile SKILLS replacements (replace existing skills lines in order)
    sk_lines = _as_lines(rewrite_packet.get("technical_skills"))
    k_refs = [r for r in _sorted_refs("K") if line_index.get(r, {}).get("section") == "SKILLS" and not _is_heading_line(r)]
    for i in range(min(len(sk_lines), len(k_refs))):
        ref = k_refs[i]
        before = line_index[ref]["text"]
        after0 = _preserve_bullet(before, sk_lines[i])
        proposals.append({
            "section": "SKILLS",
            "op": "REPLACE_LINE",
            "before_ref": ref,
            "before": [before],
            "after": [after0],
            "rationale": f"Rewrite packet skills update for {ref}.",
        })

    # Compile EXPERIENCE replacements (explicit targets)
    exp_items = rewrite_packet.get("experience") or []
    if isinstance(exp_items, list):
        for item in exp_items:
            if not isinstance(item, dict):
                continue
            ref = (item.get("target") or "").strip()
            action = (item.get("action") or "REPLACE_LINE").strip().upper()
            new_line = item.get("new_line")
            if not ref or ref not in line_index:
                continue
            if not isinstance(new_line, str) or not new_line.strip():
                continue
            before = line_index[ref]["text"]
            after0 = _preserve_bullet(before, new_line.strip())
            op = "REPLACE_LINE" if action == "REPLACE_LINE" else "REPLACE_LINE"
            proposals.append({
                "section": "EXPERIENCE",
                "op": op,
                "before_ref": ref,
                "before": [before],
                "after": [after0],
                "rationale": f"Rewrite packet experience update for {ref}.",
            })

    if not isinstance(rewrite_packet, dict):
        die("invalid rewrite_packet: must be an object")
    if not isinstance(proposals, list):
        die("invalid proposals: must be a list")

    # Enforce before_ref exists and before[0] exact match (no legacy heuristics)
    # Deterministic proposal normalization:
    # - Require before_ref exists
    # - Inject before[0] from line_index (source of truth)
    # - No legacy heuristics
    cleaned = []
    used_before_refs = set()

    for p in proposals:
        if not isinstance(p, dict):
            continue

        before_ref = (p.get("before_ref") or "").strip()
        if not before_ref or before_ref not in line_index:
            continue

        if before_ref in used_before_refs:
            continue
        used_before_refs.add(before_ref)

        expected_before = line_index[before_ref]["text"]

        section = (p.get("section") or "").strip().upper()
        op = (p.get("op") or "").strip().upper()
        after = p.get("after")
        rationale = p.get("rationale")

        # Normalize after to list[str] for schema consistency
        if isinstance(after, str):
            after = [after]
        if not isinstance(after, list) or not after or not isinstance(after[0], str):
            continue

        cleaned.append({
            "section": section,
            "op": op,
            "before_ref": before_ref,
            "before": [expected_before],
            "after": [after[0]],
            "rationale": rationale,
        })

    ok, msg = validate_proposals({"narrative": None, "proposals": cleaned})
    if not ok:
        die(f"proposal schema failed: {msg}")

    # Write rewrite packet artifacts
    notes_dir = app / "notes"
    notes_dir.mkdir(parents=True, exist_ok=True)
    raw_json_p = notes_dir / "rewrite-packet.json"
    md_p = notes_dir / "rewrite-packet.md"
    raw_json_p.write_text(json.dumps(payload, indent=2, ensure_ascii=False) + "\n")
    md_p.write_text(render_rewrite_packet_md(payload) + "\n")

    out_dir = app / "resume_refs"
    out_dir.mkdir(parents=True, exist_ok=True)
    out_p = out_dir / "edit-proposals.json"

    out_payload = {
        "app": str(app),
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "job": {
            "company": jm.get("company"),
            "role_title": jm.get("role_title"),
            "date_found": jm.get("date_found"),
        },
        "selected_template": template_folder_name,
        "narrative": (rewrite_packet.get("notes") if isinstance(rewrite_packet.get("notes"), str) else None),
        "proposals": cleaned,
        "notes": "READ-ONLY proposals. Approve with resume-approve-edits.",
    }

    if args.no_write:
        print("NOTE: --no-write set; not writing edit-proposals.json")
    else:
        out_p.write_text(json.dumps(out_payload, indent=2, ensure_ascii=False) + "\n")

    if args.diff:
        print_diff(cleaned)

    print(f"TEMPLATE: {template_folder_name}")
    print(f"PROPOSALS: {len(cleaned)}")
    print(f"WROTE: {raw_json_p}")
    print(f"WROTE: {md_p}")
    if not args.no_write:
        print(f"WROTE: {out_p}")

if __name__ == "__main__":
    main()
