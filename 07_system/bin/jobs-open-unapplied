#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF' >&2
usage:
  jobs-open-unapplied [--limit N] [--queue /tmp/file.txt] [--dry-run] [--require-date YYYY-MM-DD]

behavior:
  - scans ~/secondbrain/01_projects/jobs/**/tracking/job-meta.json
  - selects status == not_applied
  - optional: filters to date_found == --require-date
  - opens up to --limit URLs (prefers jd/job-post-url.txt if present, else job-meta.source)
  - writes selected APP paths to --queue (one per line)

notes:
  - default limit: 25
  - default queue: /tmp/applied-YYYY-MM-DD-batch1.txt is handled by jobs-apply-batch (preferred)

examples:
  jobs-open-unapplied --limit 10 --dry-run
  jobs-open-unapplied --limit 25 --require-date "$(date +%F)"
EOF
  exit 2
}

LIMIT=25
QUEUE=""
DRYRUN=0
REQUIRE_DATE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --limit) LIMIT="${2:-}"; shift 2 ;;
    --queue) QUEUE="${2:-}"; shift 2 ;;
    --dry-run) DRYRUN=1; shift ;;
    --require-date) REQUIRE_DATE="${2:-}"; shift 2 ;;
    -h|--help) usage ;;
    *) echo "Unknown arg: $1" >&2; usage ;;
  esac
done

[[ "$LIMIT" =~ ^[0-9]+$ ]] || { echo "ERROR: --limit must be numeric" >&2; exit 1; }
[[ -z "$QUEUE" ]] && { echo "ERROR: --queue is required (use jobs-apply-batch)" >&2; exit 1; }

ROOT="$HOME/secondbrain/01_projects/jobs"
[[ -d "$ROOT" ]] || { echo "ERROR: jobs root missing: $ROOT" >&2; exit 1; }

TMP="$(mktemp)"
trap 'rm -f "$TMP" 2>/dev/null || true' EXIT

python3 - "$ROOT" "$LIMIT" "$REQUIRE_DATE" > "$TMP" <<'PY'
import json, sys
from pathlib import Path

root = Path(sys.argv[1])
limit = int(sys.argv[2])
req_date = sys.argv[3].strip()

def read_json(p: Path):
    try:
        return json.loads(p.read_text())
    except Exception:
        return None

def get_url(app: Path, meta: dict):
    url_file = app / "jd" / "job-post-url.txt"
    if url_file.exists():
        u = url_file.read_text().strip()
        if u:
            return u
    u = (meta or {}).get("source","") or ""
    return u.strip()

rows = []
for jm in root.rglob("tracking/job-meta.json"):
    meta = read_json(jm)
    if not meta:
        continue
    if meta.get("status") != "not_applied":
        continue
    if req_date and meta.get("date_found") != req_date:
        continue

    app = jm.parent.parent
    url = get_url(app, meta)
    if not url or not url.startswith("http"):
        continue

    rows.append((
        meta.get("date_found",""),
        meta.get("company",""),
        meta.get("role_title",""),
        url,
        str(app)
    ))

# sort: newest date first, then company, then role
rows.sort(key=lambda r: (r[0], r[1], r[2]), reverse=True)

rows = rows[:limit]

# output TSV: company, role, date, url, app
for r in rows:
    print("\t".join(r))
PY

COUNT="$(wc -l < "$TMP" | tr -d ' ')"

if [[ "$COUNT" -eq 0 ]]; then
  echo "Opening 0 URL(s):"
  echo "Wrote queue file: $QUEUE"
  : > "$QUEUE"
  exit 0
fi

echo "Opening $COUNT URL(s):"
: > "$QUEUE"

while IFS=$'\t' read -r COMPANY ROLE FOUND URL APP; do
  echo "- $COMPANY | $ROLE | $FOUND | $URL"
  echo "  $APP"
  echo "$APP" >> "$QUEUE"

  if (( DRYRUN == 0 )); then
    open "$URL"
  fi
done < "$TMP"

echo
echo "Wrote queue file: $QUEUE"
