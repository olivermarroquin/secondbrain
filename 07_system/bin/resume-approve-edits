#!/Users/olivermarroquin/secondbrain/07_system/venvs/docgen/bin/python
import argparse, json, os, re, subprocess, sys, shutil, difflib
from pathlib import Path

# --- Helpers ---------------------------------------------------------------

def die(msg: str, code: int = 1):
    print(f"ERROR: {msg}", file=sys.stderr)
    sys.exit(code)

def norm(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "").strip()).lower()

def load_json(path: Path):
    try:
        return json.loads(path.read_text())
    except Exception as e:
        die(f"Failed to read JSON: {path} ({e})")

def ensure_docx():
    try:
        import docx  # noqa: F401
    except Exception as e:
        die(f"python-docx not available in this interpreter ({e}). "
            f"Expected docgen venv python at: {sys.executable}")

def read_job_meta(app: Path) -> dict:
    jm = app / "tracking" / "job-meta.json"
    if not jm.exists():
        die(f"Missing job-meta.json: {jm}")
    return load_json(jm)

def read_template_from_select(app: Path):
    """
    Uses the same signals-driven selection that resume-select uses by shelling out to resume-select,
    then parsing the 'Best pick' block. This keeps behavior consistent without duplicating logic here.
    """
    r = subprocess.run(
        ["resume-select", "--app", str(app)],
        capture_output=True, text=True
    )
    if r.returncode != 0:
        die(f"resume-select failed:\n{r.stderr}\n{r.stdout}")

    tid = slug = tpath = None
    for line in r.stdout.splitlines():
        line = line.strip()
        if line.startswith("- template_id:"):
            tid = line.split(":", 1)[1].strip()
        elif line.startswith("- template_slug:"):
            slug = line.split(":", 1)[1].strip()
        elif line.startswith("- template_path:"):
            tpath = line.split(":", 1)[1].strip()

    if not (tid and slug and tpath):
        die("Could not parse template from resume-select output. "
            "Expected Best pick block with template_id/template_slug/template_path.")

    tdir = Path(tpath)
    master = tdir / "resume-master.docx"
    if not master.exists():
        die(f"Missing template resume-master.docx: {master}")

    return tid, slug, tdir, master

def parse_proposals(p: Path):
    d = load_json(p)
    if isinstance(d, dict) and "proposals" in d and isinstance(d["proposals"], list):
        return d["proposals"]
    if isinstance(d, list):
        return d
    die(f"Unexpected edit-proposals.json structure: {p}")

def select_by_numbers(proposals, nums):
    if not nums:
        return proposals
    out = []
    for n in nums:
        i = n - 1
        if i < 0 or i >= len(proposals):
            die(f"Invalid proposal number: {n} (have {len(proposals)})")
        out.append(proposals[i])
    return out

def apply_replace_line(doc, before_line: str, after_line: str) -> bool:
    """
    Replace an entire paragraph that matches before_line.
    Formatting preservation:
      - If paragraph matches (normalized), clear runs and add one run using first run formatting.
      - If before_line exists as raw substring inside a paragraph, attempt per-run replace; else rebuild paragraph.
    """
    b_raw = (before_line or "").strip()
    a_raw = (after_line or "").strip()
    if not b_raw:
        return False

    b_n = norm(b_raw)

    for para in doc.paragraphs:
        t = para.text or ""
        tn = norm(t)
        if not tn:
            continue

        # Case 1: exact paragraph match (normalized)
        if tn == b_n:
            # Special-case: SKILLS lines often use 2 runs (bold label + normal values).
            # If so, preserve that structure instead of collapsing to a single run.
            if len(para.runs) == 2:
                r0, r1 = para.runs[0], para.runs[1]
                r0_text = (r0.text or "").strip()
                if (r0.bold is True) and ((r1.bold is False) or (r1.bold is None)) and r0_text.endswith(":") and (":" in a_raw):
                    label, rest = a_raw.split(":", 1)
                    r0.text = label.strip() + ":"
                    r1.text = " " + rest.strip()
                    return True
            # Default: replace whole paragraph.
            # If this is a skills-like line (label/value separated by ':'), enforce 2-run output:
            #   - label (bold)
            #   - values (not bold)
            tpl = para.runs[0] if para.runs else None
            for r in list(para.runs):
                r.text = ""

            # If BEFORE looked like a labeled line and AFTER also has a label, split into label/value runs.
            if ":" in b_raw and ":" in a_raw:
                label, rest = a_raw.split(":", 1)
                r0 = para.add_run(label.strip() + ":")
                r0.bold = True
                r1 = para.add_run(" " + rest.strip())
                r1.bold = False
                return True

            # Otherwise fall back to single-run replace, preserving the template run style.
            r_new = para.add_run(a_raw)
            if tpl is not None:
                r_new.bold = tpl.bold
                r_new.italic = tpl.italic
                r_new.underline = tpl.underline
                if tpl.font is not None:
                    r_new.font.name = tpl.font.name
                    r_new.font.size = tpl.font.size
            return True
        # Case 2: raw substring present -> prefer per-run replace
        if b_raw in t:
            for r in para.runs:
                if b_raw in r.text:
                    r.text = r.text.replace(b_raw, a_raw, 1)
                    return True

            # spans runs -> rebuild paragraph using first run formatting
            tpl = para.runs[0] if para.runs else None
            new_text = t.replace(b_raw, a_raw, 1)
            for rr in list(para.runs):
                rr.text = ""
            r2 = para.add_run(new_text)
            if tpl is not None:
                r2.bold = tpl.bold
                r2.italic = tpl.italic
                r2.underline = tpl.underline
                if tpl.font is not None:
                    r2.font.name = tpl.font.name
                    r2.font.size = tpl.font.size
            return True

        # Case 3: normalized containment (fallback) -> only if short paragraph (avoid nuking big blocks)
    # Case 3: normalized containment (fallback) -> only if short paragraph (avoid nuking big blocks)
    if b_n in tn and len(t) <= 200:
        tpl = para.runs[0] if para.runs else None
        for rr in list(para.runs):
            rr.text = ""

        # If template is bold-label style and the new line has a label/value split, preserve 2-run structure
        if tpl is not None and (tpl.bold is True) and (":" in a_raw):
            label, rest = a_raw.split(":", 1)
            r0 = para.add_run(label.strip() + ":")
            r0.bold = True
            r1 = para.add_run(" " + rest.strip())
            r1.bold = False
            if tpl.font is not None:
                for rr in (r0, r1):
                    rr.font.name = tpl.font.name
                    rr.font.size = tpl.font.size
            return True

        r3 = para.add_run(a_raw)
        if tpl is not None:
            r3.bold = tpl.bold
            r3.italic = tpl.italic
            r3.underline = tpl.underline
            if tpl.font is not None:
                r3.font.name = tpl.font.name
                r3.font.size = tpl.font.size
        return True


    return False

def apply_replace_phrase(doc, before_phrase: str, after_phrase: str) -> bool:
    """
    Replace a phrase inside paragraphs while preserving run formatting.
    Works even when the phrase spans runs by rebuilding paragraph text using first-run formatting.
    """
    b = (before_phrase or "")
    a = (after_phrase or "")
    if not b:
        return False

    for para in doc.paragraphs:
        t = para.text or ""
        if b not in t:
            continue

        # Prefer per-run replacement first
        for r in para.runs:
            if b in r.text:
                r.text = r.text.replace(b, a, 1)
                return True

        # Phrase spans runs: rebuild paragraph, preserve first run formatting
        tpl = para.runs[0] if para.runs else None
        new_text = t.replace(b, a, 1)
        for rr in list(para.runs):
            rr.text = ""
        r2 = para.add_run(new_text)
        if tpl is not None:
            r2.bold = tpl.bold
            r2.italic = tpl.italic
            r2.underline = tpl.underline
            if tpl.font is not None:
                r2.font.name = tpl.font.name
                r2.font.size = tpl.font.size
        return True

    return False


def _utc_stamp() -> str:
    from datetime import datetime, timezone
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H%M%SZ")

def _docx_text(docx_path: Path) -> str:
    """
    Extract readable text from a DOCX for stable diffs.
    (Paragraph text only; good enough for resume deltas.)
    """
    from docx import Document  # type: ignore
    d = Document(str(docx_path))
    lines = []
    for para in getattr(d, "paragraphs", []):
        t = (para.text or "").rstrip()
        lines.append(t)
    return "\n".join(lines).strip() + "\n"


def _cleanup_blank_paragraphs(doc) -> int:
    """
    Collapse/trim empty paragraphs to prevent big gaps after DELETE_LINE.
    - remove leading/trailing blank paragraphs
    - collapse consecutive blank paragraphs to at most 1
    Returns number removed.
    """
    removed = 0

    def is_blank(para) -> bool:
        txt = (para.text or "")
        if txt.strip():
            return False
        for r in getattr(para, "runs", []):
            if (getattr(r, "text", "") or "").strip():
                return False
        return True

    def remove_para(para):
        nonlocal removed
        p_elm = para._p
        parent = p_elm.getparent()
        if parent is None:
            return
        parent.remove(p_elm)
        removed += 1

    # Remove leading blanks
    while True:
        paras = list(getattr(doc, "paragraphs", []))
        if not paras:
            return removed
        if is_blank(paras[0]):
            remove_para(paras[0])
            continue
        break

    # Remove trailing blanks
    while True:
        paras = list(getattr(doc, "paragraphs", []))
        if not paras:
            return removed
        if is_blank(paras[-1]):
            remove_para(paras[-1])
            continue
        break

    # Collapse consecutive blanks
    prev_blank = False
    for para in list(getattr(doc, "paragraphs", [])):
        blank = is_blank(para)
        if blank and prev_blank:
            remove_para(para)
            continue
        prev_blank = blank

    return removed


# --- Main ------------------------------------------------------------------

def _iter_paragraphs(doc):
    return list(getattr(doc, 'paragraphs', []))

def apply_add_line(doc, anchor_line: str, new_line: str) -> bool:
    # Insert new_line AFTER the paragraph whose text equals anchor_line,
    # by CLONING the anchor paragraph XML to preserve *all* formatting
    # (indent/tab stops/table cell context/run styles).
    anchor_line = (anchor_line or '').strip()
    new_line = (new_line or '').strip()
    if not anchor_line or not new_line:
        return False

    import copy
    from docx.text.paragraph import Paragraph

    for para in _iter_paragraphs(doc):
        if (para.text or '').strip() == anchor_line:
            # 1) Clone the anchor paragraph XML and insert it after the anchor
            new_p = copy.deepcopy(para._p)
            para._p.addnext(new_p)
            new_para = Paragraph(new_p, para._parent)

            # 2) Clear all run text but keep formatting
            for r in list(new_para.runs):
                r.text = ""

            # 3) Refill using the template’s common 2-run pattern: bold label + normal values
            if ":" in new_line:
                label, rest = new_line.split(":", 1)
                label = label.strip() + ":"
                rest = " " + rest.strip()

                if len(new_para.runs) >= 2:
                    r0, r1 = new_para.runs[0], new_para.runs[1]
                    r0.text = label
                    r0.bold = True  # force label bold (matches SKILLS rows)
                    r1.text = rest
                    if r1.bold is True:
                        r1.bold = False
                else:
                    # fallback if clone produced no runs
                    r0 = new_para.add_run(label)
                    r0.bold = True
                    r1 = new_para.add_run(rest)
                    r1.bold = False
            else:
                # single-line fallback
                if new_para.runs:
                    new_para.runs[0].text = new_line
                else:
                    new_para.add_run(new_line)

            return True

    return False

def apply_delete_line(doc, target_line: str) -> bool:
    # Delete the paragraph whose text exactly equals target_line.
    target_line = (target_line or '').strip()
    if not target_line:
        return False

    for para in _iter_paragraphs(doc):
        if (para.text or '').strip() == target_line:
            p_elm = para._p
            parent = p_elm.getparent()
            if parent is None:
                return False
            parent.remove(p_elm)
            return True
    return False


def main():
    ensure_docx()
    from docx import Document  # type: ignore

    ap = argparse.ArgumentParser(
        prog="resume-approve-edits",
        description="Apply edit proposals to a selected resume template and write a single final resume (no locked/flex split)."
    )
    ap.add_argument("--app", required=True, help="Absolute path to application folder")
    ap.add_argument("--numbers", nargs="*", type=int, default=[], help="Apply only these proposal numbers (1-based). Default: all.")
    ap.add_argument("--dry-run", action="store_true", help="Validate + show what would apply, but do not write files.")
    ap.add_argument("--force", action="store_true", help="Overwrite existing resume.docx if it exists.")
    ap.add_argument("--allow-missing", action="store_true", help="Do not fail if a proposal cannot be applied.")
    ap.add_argument("--open", action="store_true", help="Open the generated resume.docx after writing (macOS 'open').")

    args = ap.parse_args()

    app = Path(args.app).expanduser().resolve()
    if not app.is_dir():
        die(f"App dir missing: {app}")

    # Required inputs
    props_path = app / "resume_refs" / "edit-proposals.json"
    if not props_path.exists():
        die(f"Missing proposals file: {props_path}")

    # Determine template via resume-select
    tid, slug, tdir, master = read_template_from_select(app)

    # Load proposals
    proposals = parse_proposals(props_path)
    chosen = select_by_numbers(proposals, args.numbers)

    if not chosen:
        die("No proposals to apply.")

    # Load template docx
    doc = Document(str(master))

    print(f"APP: {app}")
    jm = read_job_meta(app)
    print(f"JOB: {jm.get('company','?')} | {jm.get('role_title','?')} | date_found={jm.get('date_found','?')} | status={jm.get('status','?')}")
    print()
    print("TEMPLATE:")
    print(f"- template_id: {tid}")
    print(f"- template_slug: {slug}")
    print(f"- template_path: {tdir}")
    print(f"- resume-master.docx: {master}")
    print()
    print(f"Proposals selected: {len(chosen)} of {len(proposals)}")

    applied = []
    failed = []

    for idx, pr in enumerate(chosen, start=1):
        section = pr.get("section", "?")
        op = pr.get("op", "?")
        before = pr.get("before", [])
        after = pr.get("after", [])
        rationale = pr.get("rationale", "")

        b = before[0] if isinstance(before, list) and before else ""
        a = after[0] if isinstance(after, list) and after else ""

        if op == "REPLACE_LINE":
            ok = apply_replace_line(doc, b, a)
            if not ok:
                ok = apply_replace_phrase(doc, b, a) # fallback
        elif op == "ADD_LINE":
            ok = apply_add_line(doc, b, a)
        elif op == "DELETE_LINE":
            ok = apply_delete_line(doc, b)
        elif op == "REPLACE_PHRASE":
            ok = apply_replace_phrase(doc, b, a)
        else:
            failed.append({"proposal": pr, "error": f"Unsupported op: {op}"})
            continue
        if ok:
            applied.append({
                "n": idx,
                "section": section,
                "op": op,
                "before": b,
                "after": a,
                "rationale": rationale
            })
        else:
            failed.append({
              "proposal": pr,
              "error": "Target line not found in DOCX paragraphs",
              "before": b,
              "after": a
            })

    print()
    print(f"APPLIED: {len(applied)}")
    for x in applied:
        print(f"- {x['n']}. [{x['section']}] {x['op']}")

    print()
    print(f"FAILED: {len(failed)}")
    for f in failed[:10]:
        pr = f.get("proposal", {})
        b = (f.get("before") or "")
        b = b if len(b) <= 140 else (b[:139] + "…")
        print(f"- [{pr.get('section','?')}] {pr.get('op','?')}: {f.get('error','?')} | BEFORE: {b}")
    if len(failed) > 10:
        print(f"  ... {len(failed)-10} more")

    # Fail policy
    if failed and not args.allow_missing:
        if args.dry_run:
            print("\nDRY RUN — nothing written.")
        die("One or more proposals could not be applied. Fix proposals or re-run with --allow-missing.", 2)

    out_dir = app / "resume_refs"
    out_dir.mkdir(parents=True, exist_ok=True)


    out_path = out_dir / "resume.docx"
    # --- C) Resume diff vs previous resume (when overwriting) ----------------
        # out_path already set earlier (C: diff vs previous)
    stamp = _utc_stamp()

    prev_path = None
    if out_path.exists() and args.force:
        # Archive the previous resume.docx
        hist_dir = out_dir / "resume_history"
        hist_dir.mkdir(parents=True, exist_ok=True)
        prev_path = hist_dir / f"{stamp}_resume.docx"
        shutil.copy2(out_path, prev_path)

    # We'll write the NEW resume to out_path later (existing behavior).
    out_docx = out_dir / "resume.docx"
    log_path = out_dir / "edits-applied.json"

    if args.dry_run:
        print("\nDRY RUN — nothing written.")
        return

    if out_docx.exists() and not args.force:
        die(f"Refusing to overwrite existing file: {out_docx} (use --force)")

    # Write resume + log
        _cleanup_blank_paragraphs(doc)

    # Write resume + log
    _cleanup_blank_paragraphs(doc)
    _fix_summary_to_skills_spacing(doc)
    doc.save(str(out_docx))

    # If we archived a previous resume, generate a text diff for review
    if prev_path is not None and prev_path.exists() and out_path.exists():
        diffs_dir = out_dir / "diffs_history"
        diffs_dir.mkdir(parents=True, exist_ok=True)
        a = _docx_text(prev_path).splitlines(keepends=True)
        b = _docx_text(out_path).splitlines(keepends=True)
        diff = difflib.unified_diff(a, b, fromfile=str(prev_path.name), tofile=str(out_path.name))
        diff_path = diffs_dir / f"{stamp}_resume.diff"
        diff_path.write_text("".join(diff), encoding="utf-8")
        print(f"WROTE: {diff_path}")
    log = {
        "app": str(app),
        "template_id": tid,
        "template_slug": slug,
        "template_path": str(tdir),
        "master_docx": str(master),
        "output_docx": str(out_docx),
        "applied_count": len(applied),
        "failed_count": len(failed),
        "applied": applied,
        "failed": failed,
    }
    log_path.write_text(json.dumps(log, indent=2) + "\n")

    print(f"\nWROTE: {out_docx}")
    print(f"WROTE: {log_path}")

    if args.open:
        # Optional override: open with a specific macOS app name OR bundle id.
        # If LibreOffice is requested, use soffice directly (more reliable than macOS 'open' for delivering file-open events).
        target = (os.environ.get("RESUME_OPEN_WITH") or "").strip()
        try:
            lo_soffice = "/Applications/LibreOffice.app/Contents/MacOS/soffice"
            t = target.lower()

            if target and ("libreoffice" in t or "org.libreoffice" in t) and os.path.exists(lo_soffice):
                subprocess.Popen([lo_soffice, "--writer", str(out_docx)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                subprocess.run(["osascript", "-e", 'tell application "LibreOffice" to activate'], check=False)

            elif target:
                if "." in target:
                    subprocess.run(["open", "-b", target, str(out_docx)], check=False)
                else:
                    subprocess.run(["open", "-a", target, str(out_docx)], check=False)

            else:
                subprocess.run(["open", str(out_docx)], check=False)
        except Exception:
            pass


def _fix_summary_to_skills_spacing(doc) -> int:
    """
    Remove blank paras + reset spacing between PROFESSIONAL SUMMARY and TECHNICAL SKILL.
    Returns number of paragraphs removed/adjusted (best-effort).
    """
    changed = 0

    def is_blank(para) -> bool:
        txt = (para.text or "")
        if txt.strip():
            return False
        # Treat NBSP as blank too
        if txt.replace("\u00a0", "").strip():
            return False
        for r in getattr(para, "runs", []):
            if (getattr(r, "text", "") or "").replace("\u00a0", "").strip():
                return False
        return True

    def remove_para(para):
        nonlocal changed
        p_elm = para._p
        parent = p_elm.getparent()
        if parent is None:
            return
        parent.remove(p_elm)
        changed += 1

    # Locate markers
    paras = list(getattr(doc, "paragraphs", []))
    start = end = None
    for i, para in enumerate(paras):
        t = (para.text or "").strip()
        if t == "PROFESSIONAL SUMMARY:":
            start = i
        if t == "TECHNICAL SKILL:" and start is not None:
            end = i
            break

    if start is None or end is None or end <= start:

        # Add stable visual spacing (avoid blank paragraphs)
        try:
            from docx.shared import Pt  # type: ignore
            paras = list(getattr(doc, "paragraphs", []))
            # Re-locate markers after any deletions
            start = end = None
            for i, para in enumerate(paras):
                tt = (para.text or "").strip()
                if tt == "PROFESSIONAL SUMMARY:":
                    start = i
                if tt == "TECHNICAL SKILL:" and start is not None:
                    end = i
                    break
            if start is not None:
                paras[start].paragraph_format.space_after = Pt(6)
            # first non-blank after summary heading = summary paragraph
            summary_i = None
            if start is not None:
                for j in range(start+1, len(paras)):
                    if (paras[j].text or "").strip():
                        summary_i = j
                        break
            if summary_i is not None:
                paras[summary_i].paragraph_format.space_after = Pt(6)
            if end is not None:
                paras[end].paragraph_format.space_before = Pt(6)
        except Exception:
            pass

        return changed
    # Refresh list after deletions as we go
    # Remove blank paragraphs in between
    paras = list(getattr(doc, "paragraphs", []))
    # Recompute indices once more
    start = end = None
    for i, para in enumerate(paras):
        t = (para.text or "").strip()
        if t == "PROFESSIONAL SUMMARY:":
            start = i
        if t == "TECHNICAL SKILL:" and start is not None:
            end = i
            break
    if start is None or end is None or end <= start:
        return changed

    # Remove blanks strictly between the summary text and skills header
    # (we remove any blank paras between start+1 and end-1)
    # Iterate on a snapshot because doc.paragraphs updates after removal
    for para in list(getattr(doc, "paragraphs", []))[start+1:end]:
        if is_blank(para):
            remove_para(para)

    # Normalize spacing on the last non-blank paragraph before TECHNICAL SKILL
    paras = list(getattr(doc, "paragraphs", []))
    # Find TECHNICAL SKILL again
    end = None
    for i, para in enumerate(paras):
        if (para.text or "").strip() == "TECHNICAL SKILL:":
            end = i
            break
    if end is None:
        return changed

    # Walk backwards to find last non-blank paragraph before skills header
    for j in range(end-1, -1, -1):
        para = paras[j]
        if (para.text or "").strip() and (para.text or "").strip() != "PROFESSIONAL SUMMARY:":
            try:
                pf = para.paragraph_format
                pf.space_after = 0
                pf.space_before = 0
                changed += 1
            except Exception:
                pass
            break

    return changed


if __name__ == "__main__":
    main()
