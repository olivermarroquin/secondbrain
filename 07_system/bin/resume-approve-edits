#!/Users/olivermarroquin/secondbrain/07_system/venvs/docgen/bin/python
import argparse, json, os, re, subprocess, sys
from pathlib import Path

# --- Helpers ---------------------------------------------------------------

def die(msg: str, code: int = 1):
    print(f"ERROR: {msg}", file=sys.stderr)
    sys.exit(code)

def norm(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "").strip()).lower()

def load_json(path: Path):
    try:
        return json.loads(path.read_text())
    except Exception as e:
        die(f"Failed to read JSON: {path} ({e})")

def ensure_docx():
    try:
        import docx  # noqa: F401
    except Exception as e:
        die(f"python-docx not available in this interpreter ({e}). "
            f"Expected docgen venv python at: {sys.executable}")

def read_job_meta(app: Path) -> dict:
    jm = app / "tracking" / "job-meta.json"
    if not jm.exists():
        die(f"Missing job-meta.json: {jm}")
    return load_json(jm)

def read_template_from_select(app: Path):
    """
    Uses the same signals-driven selection that resume-select uses by shelling out to resume-select,
    then parsing the 'Best pick' block. This keeps behavior consistent without duplicating logic here.
    """
    r = subprocess.run(
        ["resume-select", "--app", str(app)],
        capture_output=True, text=True
    )
    if r.returncode != 0:
        die(f"resume-select failed:\n{r.stderr}\n{r.stdout}")

    tid = slug = tpath = None
    for line in r.stdout.splitlines():
        line = line.strip()
        if line.startswith("- template_id:"):
            tid = line.split(":", 1)[1].strip()
        elif line.startswith("- template_slug:"):
            slug = line.split(":", 1)[1].strip()
        elif line.startswith("- template_path:"):
            tpath = line.split(":", 1)[1].strip()

    if not (tid and slug and tpath):
        die("Could not parse template from resume-select output. "
            "Expected Best pick block with template_id/template_slug/template_path.")

    tdir = Path(tpath)
    master = tdir / "resume-master.docx"
    if not master.exists():
        die(f"Missing template resume-master.docx: {master}")

    return tid, slug, tdir, master

def parse_proposals(p: Path):
    d = load_json(p)
    if isinstance(d, dict) and "proposals" in d and isinstance(d["proposals"], list):
        return d["proposals"]
    if isinstance(d, list):
        return d
    die(f"Unexpected edit-proposals.json structure: {p}")

def select_by_numbers(proposals, nums):
    if not nums:
        return proposals
    out = []
    for n in nums:
        i = n - 1
        if i < 0 or i >= len(proposals):
            die(f"Invalid proposal number: {n} (have {len(proposals)})")
        out.append(proposals[i])
    return out

def apply_replace_line(doc, before_line: str, after_line: str) -> bool:
    """
    Replace an entire paragraph that matches before_line.
    Formatting preservation:
      - If paragraph matches (normalized), clear runs and add one run using first run formatting.
      - If before_line exists as raw substring inside a paragraph, attempt per-run replace; else rebuild paragraph.
    """
    b_raw = (before_line or "").strip()
    a_raw = (after_line or "").strip()
    if not b_raw:
        return False

    b_n = norm(b_raw)

    for para in doc.paragraphs:
        t = para.text or ""
        tn = norm(t)
        if not tn:
            continue

        # Case 1: exact paragraph match (normalized) -> replace whole paragraph, preserve formatting
        if tn == b_n:
            tpl = para.runs[0] if para.runs else None
            for r in list(para.runs):
                r.text = ""
            r_new = para.add_run(a_raw)
            if tpl is not None:
                r_new.bold = tpl.bold
                r_new.italic = tpl.italic
                r_new.underline = tpl.underline
                if tpl.font is not None:
                    r_new.font.name = tpl.font.name
                    r_new.font.size = tpl.font.size
            return True

        # Case 2: raw substring present -> prefer per-run replace
        if b_raw in t:
            for r in para.runs:
                if b_raw in r.text:
                    r.text = r.text.replace(b_raw, a_raw, 1)
                    return True

            # spans runs -> rebuild paragraph using first run formatting
            tpl = para.runs[0] if para.runs else None
            new_text = t.replace(b_raw, a_raw, 1)
            for rr in list(para.runs):
                rr.text = ""
            r2 = para.add_run(new_text)
            if tpl is not None:
                r2.bold = tpl.bold
                r2.italic = tpl.italic
                r2.underline = tpl.underline
                if tpl.font is not None:
                    r2.font.name = tpl.font.name
                    r2.font.size = tpl.font.size
            return True

        # Case 3: normalized containment (fallback) -> only if short paragraph (avoid nuking big blocks)
        if b_n in tn and len(t) <= 200:
            tpl = para.runs[0] if para.runs else None
            for rr in list(para.runs):
                rr.text = ""
            r3 = para.add_run(a_raw)
            if tpl is not None:
                r3.bold = tpl.bold
                r3.italic = tpl.italic
                r3.underline = tpl.underline
                if tpl.font is not None:
                    r3.font.name = tpl.font.name
                    r3.font.size = tpl.font.size
            return True

    return False

def apply_replace_phrase(doc, before_phrase: str, after_phrase: str) -> bool:
    """
    Replace a phrase inside paragraphs while preserving run formatting.
    Works even when the phrase spans runs by rebuilding paragraph text using first-run formatting.
    """
    b = (before_phrase or "")
    a = (after_phrase or "")
    if not b:
        return False

    for para in doc.paragraphs:
        t = para.text or ""
        if b not in t:
            continue

        # Prefer per-run replacement first
        for r in para.runs:
            if b in r.text:
                r.text = r.text.replace(b, a, 1)
                return True

        # Phrase spans runs: rebuild paragraph, preserve first run formatting
        tpl = para.runs[0] if para.runs else None
        new_text = t.replace(b, a, 1)
        for rr in list(para.runs):
            rr.text = ""
        r2 = para.add_run(new_text)
        if tpl is not None:
            r2.bold = tpl.bold
            r2.italic = tpl.italic
            r2.underline = tpl.underline
            if tpl.font is not None:
                r2.font.name = tpl.font.name
                r2.font.size = tpl.font.size
        return True

    return False

# --- Main ------------------------------------------------------------------

def _iter_paragraphs(doc):
    return list(getattr(doc, 'paragraphs', []))

def apply_add_line(doc, anchor_line: str, new_line: str) -> bool:
    # Insert new_line AFTER the paragraph whose text exactly equals anchor_line.
    anchor_line = (anchor_line or '').strip()
    new_line = (new_line or '').strip()
    if not anchor_line or not new_line:
        return False

    from docx.oxml import OxmlElement
    from docx.text.paragraph import Paragraph

    for para in _iter_paragraphs(doc):
        if (para.text or '').strip() == anchor_line:
            new_p = OxmlElement('w:p')
            para._p.addnext(new_p)
            new_para = Paragraph(new_p, para._parent)
            new_para.add_run(new_line)
            return True
    return False

def apply_delete_line(doc, target_line: str) -> bool:
    # Delete the paragraph whose text exactly equals target_line.
    target_line = (target_line or '').strip()
    if not target_line:
        return False

    for para in _iter_paragraphs(doc):
        if (para.text or '').strip() == target_line:
            p_elm = para._p
            parent = p_elm.getparent()
            if parent is None:
                return False
            parent.remove(p_elm)
            return True
    return False


def main():
    ensure_docx()
    from docx import Document  # type: ignore

    ap = argparse.ArgumentParser(
        prog="resume-approve-edits",
        description="Apply edit proposals to a selected resume template and write a single final resume (no locked/flex split)."
    )
    ap.add_argument("--app", required=True, help="Absolute path to application folder")
    ap.add_argument("--numbers", nargs="*", type=int, default=[], help="Apply only these proposal numbers (1-based). Default: all.")
    ap.add_argument("--dry-run", action="store_true", help="Validate + show what would apply, but do not write files.")
    ap.add_argument("--force", action="store_true", help="Overwrite existing resume.docx if it exists.")
    ap.add_argument("--allow-missing", action="store_true", help="Do not fail if a proposal cannot be applied.")
    ap.add_argument("--open", action="store_true", help="Open the generated resume.docx after writing (macOS 'open').")

    args = ap.parse_args()

    app = Path(args.app).expanduser().resolve()
    if not app.is_dir():
        die(f"App dir missing: {app}")

    # Required inputs
    props_path = app / "resume_refs" / "edit-proposals.json"
    if not props_path.exists():
        die(f"Missing proposals file: {props_path}")

    # Determine template via resume-select
    tid, slug, tdir, master = read_template_from_select(app)

    # Load proposals
    proposals = parse_proposals(props_path)
    chosen = select_by_numbers(proposals, args.numbers)

    if not chosen:
        die("No proposals to apply.")

    # Load template docx
    doc = Document(str(master))

    print(f"APP: {app}")
    jm = read_job_meta(app)
    print(f"JOB: {jm.get('company','?')} | {jm.get('role_title','?')} | date_found={jm.get('date_found','?')} | status={jm.get('status','?')}")
    print()
    print("TEMPLATE:")
    print(f"- template_id: {tid}")
    print(f"- template_slug: {slug}")
    print(f"- template_path: {tdir}")
    print(f"- resume-master.docx: {master}")
    print()
    print(f"Proposals selected: {len(chosen)} of {len(proposals)}")

    applied = []
    failed = []

    for idx, pr in enumerate(chosen, start=1):
        section = pr.get("section", "?")
        op = pr.get("op", "?")
        before = pr.get("before", [])
        after = pr.get("after", [])
        rationale = pr.get("rationale", "")

        b = before[0] if isinstance(before, list) and before else ""
        a = after[0] if isinstance(after, list) and after else ""

        if op == "REPLACE_LINE":
            ok = apply_replace_line(doc, b, a)
            if not ok:
                ok = apply_replace_phrase(doc, b, a) # fallback
        elif op == "ADD_LINE":
            ok = apply_add_line(doc, b, a)
        elif op == "DELETE_LINE":
            ok = apply_delete_line(doc, b)
        elif op == "REPLACE_PHRASE":
            ok = apply_replace_phrase(doc, b, a)
        else:
            failed.append({"proposal": pr, "error": f"Unsupported op: {op}"})
            continue
        if ok:
            applied.append({
                "n": idx,
                "section": section,
                "op": op,
                "before": b,
                "after": a,
                "rationale": rationale
            })
        else:
            failed.append({
              "proposal": pr,
              "error": "Target line not found in DOCX paragraphs",
              "before": b,
              "after": a
            })

    print()
    print(f"APPLIED: {len(applied)}")
    for x in applied:
        print(f"- {x['n']}. [{x['section']}] {x['op']}")

    print()
    print(f"FAILED: {len(failed)}")
    for f in failed[:10]:
        pr = f.get("proposal", {})
        b = (f.get("before") or "")
        b = b if len(b) <= 140 else (b[:139] + "…")
        print(f"- [{pr.get('section','?')}] {pr.get('op','?')}: {f.get('error','?')} | BEFORE: {b}")
    if len(failed) > 10:
        print(f"  ... {len(failed)-10} more")

    # Fail policy
    if failed and not args.allow_missing:
        if args.dry_run:
            print("\nDRY RUN — nothing written.")
        die("One or more proposals could not be applied. Fix proposals or re-run with --allow-missing.", 2)

    out_dir = app / "resume_refs"
    out_dir.mkdir(parents=True, exist_ok=True)
    out_docx = out_dir / "resume.docx"
    log_path = out_dir / "edits-applied.json"

    if args.dry_run:
        print("\nDRY RUN — nothing written.")
        return

    if out_docx.exists() and not args.force:
        die(f"Refusing to overwrite existing file: {out_docx} (use --force)")

    # Write resume + log
    doc.save(str(out_docx))
    log = {
        "app": str(app),
        "template_id": tid,
        "template_slug": slug,
        "template_path": str(tdir),
        "master_docx": str(master),
        "output_docx": str(out_docx),
        "applied_count": len(applied),
        "failed_count": len(failed),
        "applied": applied,
        "failed": failed,
    }
    log_path.write_text(json.dumps(log, indent=2) + "\n")

    print(f"\nWROTE: {out_docx}")
    print(f"WROTE: {log_path}")

    if args.open:
        # Optional override: open with a specific macOS app name OR bundle id.
        # If LibreOffice is requested, use soffice directly (more reliable than macOS 'open' for delivering file-open events).
        target = (os.environ.get("RESUME_OPEN_WITH") or "").strip()
        try:
            lo_soffice = "/Applications/LibreOffice.app/Contents/MacOS/soffice"
            t = target.lower()

            if target and ("libreoffice" in t or "org.libreoffice" in t) and os.path.exists(lo_soffice):
                subprocess.Popen([lo_soffice, "--writer", str(out_docx)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                subprocess.run(["osascript", "-e", 'tell application "LibreOffice" to activate'], check=False)

            elif target:
                if "." in target:
                    subprocess.run(["open", "-b", target, str(out_docx)], check=False)
                else:
                    subprocess.run(["open", "-a", target, str(out_docx)], check=False)

            else:
                subprocess.run(["open", str(out_docx)], check=False)
        except Exception:
            pass

if __name__ == "__main__":
    main()
